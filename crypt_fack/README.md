# Cryptfack
Протокол: TCP.  
Язык: Си.  
Автор: @bigger777  

### Описание функционала

Cryptfack - ~~надежный~~ сервис для хранения текстовых данных. После регистрации в системе пользователю предоставляются 4 действия:

- **Load public data** - загруить данные, которые будут шифроваться сервисом и будут видны всем другим пользователям. Загрузка производилась в формате __base64__.
- **Load private data** - загрузить данные, которые не будут шифроваться и будут видны только хозяину.
- **Show public data** - просмотр публичных данных всех пользователей. 
- **Show private data** - просмотр свои приватных данных.

### Уязвимости
##### Неправильная проверка пароля  

В файле `db_api.c` в функции `db_api_login_try()` при проверке пароля используется функция `strstr(str1, str2)`, которая ищет вхождение строки `str2` в строке `str1`.  
Достаточно было перебором найти хотя бы один символ, который используется в пароле (также можно авторизваться с пустым паролем - символ `'\n'` присутствовал в конце каждой строки).  
```c
208.  if (NULL == strstr(get_pass, pass)) rc = 0;
```  
Уязвимость позволяла авторизовываться за пользователя и смотреть приватные данные, в которых лежал флаг.
В качестве фикса можно использовать функцию `strcmp()`, которая сравнивала бы пароли полностью.  

##### Слабая криптография  
Кодирование публичных данных осуществлялось с помощью побайтового XOR'а.  
Строка brainfuck'a в файле `crypt.c` после встроенной компиляции генерировала байт-код:
```sh
55          push rbp                                              
4889e5      mov rbp, rsp                                          
48897df8    mov qword [rbp - 8], rdi                              
89f0        mov eax, esi
8845f4      mov byte [rbp - 0xc], al                              
488b45f8    mov rax, qword [rbp - 8]                              
0fb600      movzx eax, byte [rax]                                 
3245f4      xor al, byte [rbp - 0xc]                              
89c2        mov edx, eax                                          
488b45f8    mov rax, qword [rbp - 8]                              
8810        mov byte [rax], dl                                    
90          nop                                                   
5d          pop rbp                                               
c3          ret
```
В функции `crypt_encrypt_data()` выделялась память с правами на исполнения, в которую записывался полученный байт-код:  
```c
119.  mem = mmap(NULL, DATA_SIZE, PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);  
...
124.  memcpy(mem, magic_data, DATA_SIZE);
```
Создавался указатель на функцию, которому присваивался указатель  на выделенную память и в цикле происходил вызов функции кодирования с ключом `0x77`:
```c
126   void (* magic) (char *, char) = mem;                                          
127                                                                                 
128   for (int i = 0; i < len; ++i)                                                 
129   {                                                                             
130     magic(&out_data[i], 0x77);                                                  
131   }
```  
В качестве фикса можно было поменять логику кодирования. 

### Публичные данные  

В качестве публичных данных чекер загружал сжатый zip'ом бинарный файл .elf, в котором лежал зашифрованный флаг.  
Алгоритм шифрования - инкрементились четные байты флага и декрементились нечетные:
```python
def encrypt_flag(flag):
    enc_flag = ""
    for c in flag:
        if ord(c) | 254 == 254:
            enc_flag += chr(ord(c) + 1)
        else:
            enc_flag += chr(ord(c) - 1)
    return enc_flag
```
